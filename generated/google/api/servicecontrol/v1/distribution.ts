/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: google/api/servicecontrol/v1/distribution.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../distribution";
import * as pb_1 from "google-protobuf";
export namespace google.api.servicecontrol.v1 {
    export class Distribution extends pb_1.Message {
        #one_of_decls: number[][] = [[7, 8, 9]];
        constructor(data?: any[] | ({
            count?: number;
            mean?: number;
            minimum?: number;
            maximum?: number;
            sum_of_squared_deviation?: number;
            bucket_counts?: number[];
            exemplars?: dependency_1.google.api.Distribution.Exemplar[];
        } & (({
            linear_buckets?: Distribution.LinearBuckets;
            exponential_buckets?: never;
            explicit_buckets?: never;
        } | {
            linear_buckets?: never;
            exponential_buckets?: Distribution.ExponentialBuckets;
            explicit_buckets?: never;
        } | {
            linear_buckets?: never;
            exponential_buckets?: never;
            explicit_buckets?: Distribution.ExplicitBuckets;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 10], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("mean" in data && data.mean != undefined) {
                    this.mean = data.mean;
                }
                if ("minimum" in data && data.minimum != undefined) {
                    this.minimum = data.minimum;
                }
                if ("maximum" in data && data.maximum != undefined) {
                    this.maximum = data.maximum;
                }
                if ("sum_of_squared_deviation" in data && data.sum_of_squared_deviation != undefined) {
                    this.sum_of_squared_deviation = data.sum_of_squared_deviation;
                }
                if ("bucket_counts" in data && data.bucket_counts != undefined) {
                    this.bucket_counts = data.bucket_counts;
                }
                if ("linear_buckets" in data && data.linear_buckets != undefined) {
                    this.linear_buckets = data.linear_buckets;
                }
                if ("exponential_buckets" in data && data.exponential_buckets != undefined) {
                    this.exponential_buckets = data.exponential_buckets;
                }
                if ("explicit_buckets" in data && data.explicit_buckets != undefined) {
                    this.explicit_buckets = data.explicit_buckets;
                }
                if ("exemplars" in data && data.exemplars != undefined) {
                    this.exemplars = data.exemplars;
                }
            }
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get mean() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set mean(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get minimum() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set minimum(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get maximum() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set maximum(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sum_of_squared_deviation() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set sum_of_squared_deviation(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get bucket_counts() {
            return pb_1.Message.getFieldWithDefault(this, 6, []) as number[];
        }
        set bucket_counts(value: number[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get linear_buckets() {
            return pb_1.Message.getWrapperField(this, Distribution.LinearBuckets, 7) as Distribution.LinearBuckets;
        }
        set linear_buckets(value: Distribution.LinearBuckets) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_linear_buckets() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get exponential_buckets() {
            return pb_1.Message.getWrapperField(this, Distribution.ExponentialBuckets, 8) as Distribution.ExponentialBuckets;
        }
        set exponential_buckets(value: Distribution.ExponentialBuckets) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_exponential_buckets() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get explicit_buckets() {
            return pb_1.Message.getWrapperField(this, Distribution.ExplicitBuckets, 9) as Distribution.ExplicitBuckets;
        }
        set explicit_buckets(value: Distribution.ExplicitBuckets) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_explicit_buckets() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get exemplars() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_1.google.api.Distribution.Exemplar, 10) as dependency_1.google.api.Distribution.Exemplar[];
        }
        set exemplars(value: dependency_1.google.api.Distribution.Exemplar[]) {
            pb_1.Message.setRepeatedWrapperField(this, 10, value);
        }
        get bucket_option() {
            const cases: {
                [index: number]: "none" | "linear_buckets" | "exponential_buckets" | "explicit_buckets";
            } = {
                0: "none",
                7: "linear_buckets",
                8: "exponential_buckets",
                9: "explicit_buckets"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7, 8, 9])];
        }
        static fromObject(data: {
            count?: number;
            mean?: number;
            minimum?: number;
            maximum?: number;
            sum_of_squared_deviation?: number;
            bucket_counts?: number[];
            linear_buckets?: ReturnType<typeof Distribution.LinearBuckets.prototype.toObject>;
            exponential_buckets?: ReturnType<typeof Distribution.ExponentialBuckets.prototype.toObject>;
            explicit_buckets?: ReturnType<typeof Distribution.ExplicitBuckets.prototype.toObject>;
            exemplars?: ReturnType<typeof dependency_1.google.api.Distribution.Exemplar.prototype.toObject>[];
        }): Distribution {
            const message = new Distribution({});
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.mean != null) {
                message.mean = data.mean;
            }
            if (data.minimum != null) {
                message.minimum = data.minimum;
            }
            if (data.maximum != null) {
                message.maximum = data.maximum;
            }
            if (data.sum_of_squared_deviation != null) {
                message.sum_of_squared_deviation = data.sum_of_squared_deviation;
            }
            if (data.bucket_counts != null) {
                message.bucket_counts = data.bucket_counts;
            }
            if (data.linear_buckets != null) {
                message.linear_buckets = Distribution.LinearBuckets.fromObject(data.linear_buckets);
            }
            if (data.exponential_buckets != null) {
                message.exponential_buckets = Distribution.ExponentialBuckets.fromObject(data.exponential_buckets);
            }
            if (data.explicit_buckets != null) {
                message.explicit_buckets = Distribution.ExplicitBuckets.fromObject(data.explicit_buckets);
            }
            if (data.exemplars != null) {
                message.exemplars = data.exemplars.map(item => dependency_1.google.api.Distribution.Exemplar.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                count?: number;
                mean?: number;
                minimum?: number;
                maximum?: number;
                sum_of_squared_deviation?: number;
                bucket_counts?: number[];
                linear_buckets?: ReturnType<typeof Distribution.LinearBuckets.prototype.toObject>;
                exponential_buckets?: ReturnType<typeof Distribution.ExponentialBuckets.prototype.toObject>;
                explicit_buckets?: ReturnType<typeof Distribution.ExplicitBuckets.prototype.toObject>;
                exemplars?: ReturnType<typeof dependency_1.google.api.Distribution.Exemplar.prototype.toObject>[];
            } = {};
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.mean != null) {
                data.mean = this.mean;
            }
            if (this.minimum != null) {
                data.minimum = this.minimum;
            }
            if (this.maximum != null) {
                data.maximum = this.maximum;
            }
            if (this.sum_of_squared_deviation != null) {
                data.sum_of_squared_deviation = this.sum_of_squared_deviation;
            }
            if (this.bucket_counts != null) {
                data.bucket_counts = this.bucket_counts;
            }
            if (this.linear_buckets != null) {
                data.linear_buckets = this.linear_buckets.toObject();
            }
            if (this.exponential_buckets != null) {
                data.exponential_buckets = this.exponential_buckets.toObject();
            }
            if (this.explicit_buckets != null) {
                data.explicit_buckets = this.explicit_buckets.toObject();
            }
            if (this.exemplars != null) {
                data.exemplars = this.exemplars.map((item: dependency_1.google.api.Distribution.Exemplar) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.count != 0)
                writer.writeInt64(1, this.count);
            if (this.mean != 0)
                writer.writeDouble(2, this.mean);
            if (this.minimum != 0)
                writer.writeDouble(3, this.minimum);
            if (this.maximum != 0)
                writer.writeDouble(4, this.maximum);
            if (this.sum_of_squared_deviation != 0)
                writer.writeDouble(5, this.sum_of_squared_deviation);
            if (this.bucket_counts.length)
                writer.writePackedInt64(6, this.bucket_counts);
            if (this.has_linear_buckets)
                writer.writeMessage(7, this.linear_buckets, () => this.linear_buckets.serialize(writer));
            if (this.has_exponential_buckets)
                writer.writeMessage(8, this.exponential_buckets, () => this.exponential_buckets.serialize(writer));
            if (this.has_explicit_buckets)
                writer.writeMessage(9, this.explicit_buckets, () => this.explicit_buckets.serialize(writer));
            if (this.exemplars.length)
                writer.writeRepeatedMessage(10, this.exemplars, (item: dependency_1.google.api.Distribution.Exemplar) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Distribution {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Distribution();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.count = reader.readInt64();
                        break;
                    case 2:
                        message.mean = reader.readDouble();
                        break;
                    case 3:
                        message.minimum = reader.readDouble();
                        break;
                    case 4:
                        message.maximum = reader.readDouble();
                        break;
                    case 5:
                        message.sum_of_squared_deviation = reader.readDouble();
                        break;
                    case 6:
                        message.bucket_counts = reader.readPackedInt64();
                        break;
                    case 7:
                        reader.readMessage(message.linear_buckets, () => message.linear_buckets = Distribution.LinearBuckets.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.exponential_buckets, () => message.exponential_buckets = Distribution.ExponentialBuckets.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.explicit_buckets, () => message.explicit_buckets = Distribution.ExplicitBuckets.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.exemplars, () => pb_1.Message.addToRepeatedWrapperField(message, 10, dependency_1.google.api.Distribution.Exemplar.deserialize(reader), dependency_1.google.api.Distribution.Exemplar));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Distribution {
            return Distribution.deserialize(bytes);
        }
    }
    export namespace Distribution {
        export class LinearBuckets extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                num_finite_buckets?: number;
                width?: number;
                offset?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("num_finite_buckets" in data && data.num_finite_buckets != undefined) {
                        this.num_finite_buckets = data.num_finite_buckets;
                    }
                    if ("width" in data && data.width != undefined) {
                        this.width = data.width;
                    }
                    if ("offset" in data && data.offset != undefined) {
                        this.offset = data.offset;
                    }
                }
            }
            get num_finite_buckets() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set num_finite_buckets(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get width() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set width(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get offset() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set offset(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                num_finite_buckets?: number;
                width?: number;
                offset?: number;
            }): LinearBuckets {
                const message = new LinearBuckets({});
                if (data.num_finite_buckets != null) {
                    message.num_finite_buckets = data.num_finite_buckets;
                }
                if (data.width != null) {
                    message.width = data.width;
                }
                if (data.offset != null) {
                    message.offset = data.offset;
                }
                return message;
            }
            toObject() {
                const data: {
                    num_finite_buckets?: number;
                    width?: number;
                    offset?: number;
                } = {};
                if (this.num_finite_buckets != null) {
                    data.num_finite_buckets = this.num_finite_buckets;
                }
                if (this.width != null) {
                    data.width = this.width;
                }
                if (this.offset != null) {
                    data.offset = this.offset;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.num_finite_buckets != 0)
                    writer.writeInt32(1, this.num_finite_buckets);
                if (this.width != 0)
                    writer.writeDouble(2, this.width);
                if (this.offset != 0)
                    writer.writeDouble(3, this.offset);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LinearBuckets {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LinearBuckets();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.num_finite_buckets = reader.readInt32();
                            break;
                        case 2:
                            message.width = reader.readDouble();
                            break;
                        case 3:
                            message.offset = reader.readDouble();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): LinearBuckets {
                return LinearBuckets.deserialize(bytes);
            }
        }
        export class ExponentialBuckets extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                num_finite_buckets?: number;
                growth_factor?: number;
                scale?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("num_finite_buckets" in data && data.num_finite_buckets != undefined) {
                        this.num_finite_buckets = data.num_finite_buckets;
                    }
                    if ("growth_factor" in data && data.growth_factor != undefined) {
                        this.growth_factor = data.growth_factor;
                    }
                    if ("scale" in data && data.scale != undefined) {
                        this.scale = data.scale;
                    }
                }
            }
            get num_finite_buckets() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set num_finite_buckets(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get growth_factor() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set growth_factor(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get scale() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set scale(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                num_finite_buckets?: number;
                growth_factor?: number;
                scale?: number;
            }): ExponentialBuckets {
                const message = new ExponentialBuckets({});
                if (data.num_finite_buckets != null) {
                    message.num_finite_buckets = data.num_finite_buckets;
                }
                if (data.growth_factor != null) {
                    message.growth_factor = data.growth_factor;
                }
                if (data.scale != null) {
                    message.scale = data.scale;
                }
                return message;
            }
            toObject() {
                const data: {
                    num_finite_buckets?: number;
                    growth_factor?: number;
                    scale?: number;
                } = {};
                if (this.num_finite_buckets != null) {
                    data.num_finite_buckets = this.num_finite_buckets;
                }
                if (this.growth_factor != null) {
                    data.growth_factor = this.growth_factor;
                }
                if (this.scale != null) {
                    data.scale = this.scale;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.num_finite_buckets != 0)
                    writer.writeInt32(1, this.num_finite_buckets);
                if (this.growth_factor != 0)
                    writer.writeDouble(2, this.growth_factor);
                if (this.scale != 0)
                    writer.writeDouble(3, this.scale);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExponentialBuckets {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExponentialBuckets();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.num_finite_buckets = reader.readInt32();
                            break;
                        case 2:
                            message.growth_factor = reader.readDouble();
                            break;
                        case 3:
                            message.scale = reader.readDouble();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ExponentialBuckets {
                return ExponentialBuckets.deserialize(bytes);
            }
        }
        export class ExplicitBuckets extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                bounds?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("bounds" in data && data.bounds != undefined) {
                        this.bounds = data.bounds;
                    }
                }
            }
            get bounds() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set bounds(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                bounds?: number[];
            }): ExplicitBuckets {
                const message = new ExplicitBuckets({});
                if (data.bounds != null) {
                    message.bounds = data.bounds;
                }
                return message;
            }
            toObject() {
                const data: {
                    bounds?: number[];
                } = {};
                if (this.bounds != null) {
                    data.bounds = this.bounds;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.bounds.length)
                    writer.writePackedDouble(1, this.bounds);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExplicitBuckets {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExplicitBuckets();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.bounds = reader.readPackedDouble();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ExplicitBuckets {
                return ExplicitBuckets.deserialize(bytes);
            }
        }
    }
}
