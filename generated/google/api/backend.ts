/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: google/api/backend.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace google.api {
    export class Backend extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rules?: BackendRule[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rules" in data && data.rules != undefined) {
                    this.rules = data.rules;
                }
            }
        }
        get rules() {
            return pb_1.Message.getRepeatedWrapperField(this, BackendRule, 1) as BackendRule[];
        }
        set rules(value: BackendRule[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            rules?: ReturnType<typeof BackendRule.prototype.toObject>[];
        }): Backend {
            const message = new Backend({});
            if (data.rules != null) {
                message.rules = data.rules.map(item => BackendRule.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                rules?: ReturnType<typeof BackendRule.prototype.toObject>[];
            } = {};
            if (this.rules != null) {
                data.rules = this.rules.map((item: BackendRule) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.rules.length)
                writer.writeRepeatedMessage(1, this.rules, (item: BackendRule) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Backend {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Backend();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.rules, () => pb_1.Message.addToRepeatedWrapperField(message, 1, BackendRule.deserialize(reader), BackendRule));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Backend {
            return Backend.deserialize(bytes);
        }
    }
    export class BackendRule extends pb_1.Message {
        #one_of_decls: number[][] = [[7, 8]];
        constructor(data?: any[] | ({
            selector?: string;
            address?: string;
            deadline?: number;
            /** @deprecated*/
            min_deadline?: number;
            operation_deadline?: number;
            path_translation?: BackendRule.PathTranslation;
            protocol?: string;
            overrides_by_request_protocol?: Map<string, BackendRule>;
        } & (({
            jwt_audience?: string;
            disable_auth?: never;
        } | {
            jwt_audience?: never;
            disable_auth?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("selector" in data && data.selector != undefined) {
                    this.selector = data.selector;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("deadline" in data && data.deadline != undefined) {
                    this.deadline = data.deadline;
                }
                if ("min_deadline" in data && data.min_deadline != undefined) {
                    this.min_deadline = data.min_deadline;
                }
                if ("operation_deadline" in data && data.operation_deadline != undefined) {
                    this.operation_deadline = data.operation_deadline;
                }
                if ("path_translation" in data && data.path_translation != undefined) {
                    this.path_translation = data.path_translation;
                }
                if ("jwt_audience" in data && data.jwt_audience != undefined) {
                    this.jwt_audience = data.jwt_audience;
                }
                if ("disable_auth" in data && data.disable_auth != undefined) {
                    this.disable_auth = data.disable_auth;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("overrides_by_request_protocol" in data && data.overrides_by_request_protocol != undefined) {
                    this.overrides_by_request_protocol = data.overrides_by_request_protocol;
                }
            }
            if (!this.overrides_by_request_protocol)
                this.overrides_by_request_protocol = new Map();
        }
        get selector() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set selector(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get deadline() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set deadline(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        /** @deprecated*/
        get min_deadline() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        /** @deprecated*/
        set min_deadline(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get operation_deadline() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set operation_deadline(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get path_translation() {
            return pb_1.Message.getFieldWithDefault(this, 6, BackendRule.PathTranslation.PATH_TRANSLATION_UNSPECIFIED) as BackendRule.PathTranslation;
        }
        set path_translation(value: BackendRule.PathTranslation) {
            pb_1.Message.setField(this, 6, value);
        }
        get jwt_audience() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set jwt_audience(value: string) {
            pb_1.Message.setOneofField(this, 7, this.#one_of_decls[0], value);
        }
        get has_jwt_audience() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get disable_auth() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set disable_auth(value: boolean) {
            pb_1.Message.setOneofField(this, 8, this.#one_of_decls[0], value);
        }
        get has_disable_auth() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set protocol(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get overrides_by_request_protocol() {
            return pb_1.Message.getField(this, 10) as any as Map<string, BackendRule>;
        }
        set overrides_by_request_protocol(value: Map<string, BackendRule>) {
            pb_1.Message.setField(this, 10, value as any);
        }
        get authentication() {
            const cases: {
                [index: number]: "none" | "jwt_audience" | "disable_auth";
            } = {
                0: "none",
                7: "jwt_audience",
                8: "disable_auth"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7, 8])];
        }
        static fromObject(data: {
            selector?: string;
            address?: string;
            deadline?: number;
            min_deadline?: number;
            operation_deadline?: number;
            path_translation?: BackendRule.PathTranslation;
            jwt_audience?: string;
            disable_auth?: boolean;
            protocol?: string;
            overrides_by_request_protocol?: {
                [key: string]: ReturnType<typeof BackendRule.prototype.toObject>;
            };
        }): BackendRule {
            const message = new BackendRule({});
            if (data.selector != null) {
                message.selector = data.selector;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.deadline != null) {
                message.deadline = data.deadline;
            }
            if (data.min_deadline != null) {
                message.min_deadline = data.min_deadline;
            }
            if (data.operation_deadline != null) {
                message.operation_deadline = data.operation_deadline;
            }
            if (data.path_translation != null) {
                message.path_translation = data.path_translation;
            }
            if (data.jwt_audience != null) {
                message.jwt_audience = data.jwt_audience;
            }
            if (data.disable_auth != null) {
                message.disable_auth = data.disable_auth;
            }
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (typeof data.overrides_by_request_protocol == "object") {
                message.overrides_by_request_protocol = new Map(Object.entries(data.overrides_by_request_protocol).map(([key, value]) => [key, BackendRule.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                selector?: string;
                address?: string;
                deadline?: number;
                min_deadline?: number;
                operation_deadline?: number;
                path_translation?: BackendRule.PathTranslation;
                jwt_audience?: string;
                disable_auth?: boolean;
                protocol?: string;
                overrides_by_request_protocol?: {
                    [key: string]: ReturnType<typeof BackendRule.prototype.toObject>;
                };
            } = {};
            if (this.selector != null) {
                data.selector = this.selector;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.deadline != null) {
                data.deadline = this.deadline;
            }
            if (this.min_deadline != null) {
                data.min_deadline = this.min_deadline;
            }
            if (this.operation_deadline != null) {
                data.operation_deadline = this.operation_deadline;
            }
            if (this.path_translation != null) {
                data.path_translation = this.path_translation;
            }
            if (this.jwt_audience != null) {
                data.jwt_audience = this.jwt_audience;
            }
            if (this.disable_auth != null) {
                data.disable_auth = this.disable_auth;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.overrides_by_request_protocol != null) {
                data.overrides_by_request_protocol = (Object.fromEntries)((Array.from)(this.overrides_by_request_protocol).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.selector.length)
                writer.writeString(1, this.selector);
            if (this.address.length)
                writer.writeString(2, this.address);
            if (this.deadline != 0)
                writer.writeDouble(3, this.deadline);
            if (this.min_deadline != 0)
                writer.writeDouble(4, this.min_deadline);
            if (this.operation_deadline != 0)
                writer.writeDouble(5, this.operation_deadline);
            if (this.path_translation != BackendRule.PathTranslation.PATH_TRANSLATION_UNSPECIFIED)
                writer.writeEnum(6, this.path_translation);
            if (this.has_jwt_audience)
                writer.writeString(7, this.jwt_audience);
            if (this.has_disable_auth)
                writer.writeBool(8, this.disable_auth);
            if (this.protocol.length)
                writer.writeString(9, this.protocol);
            for (const [key, value] of this.overrides_by_request_protocol) {
                writer.writeMessage(10, this.overrides_by_request_protocol, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BackendRule {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BackendRule();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.selector = reader.readString();
                        break;
                    case 2:
                        message.address = reader.readString();
                        break;
                    case 3:
                        message.deadline = reader.readDouble();
                        break;
                    case 4:
                        message.min_deadline = reader.readDouble();
                        break;
                    case 5:
                        message.operation_deadline = reader.readDouble();
                        break;
                    case 6:
                        message.path_translation = reader.readEnum();
                        break;
                    case 7:
                        message.jwt_audience = reader.readString();
                        break;
                    case 8:
                        message.disable_auth = reader.readBool();
                        break;
                    case 9:
                        message.protocol = reader.readString();
                        break;
                    case 10:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.overrides_by_request_protocol as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = BackendRule.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BackendRule {
            return BackendRule.deserialize(bytes);
        }
    }
    export namespace BackendRule {
        export enum PathTranslation {
            PATH_TRANSLATION_UNSPECIFIED = 0,
            CONSTANT_ADDRESS = 1,
            APPEND_PATH_TO_ADDRESS = 2
        }
    }
}
